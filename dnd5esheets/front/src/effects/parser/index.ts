/* eslint-disable */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
const peggyParser: { parse: any; SyntaxError: any; DefaultTracer?: any } = // Generated by Peggy 3.0.2.
  //
  // https://peggyjs.org/
  (function () {
    'use strict'
    function EffectExpression(target, operator, equation) {
      return {
        type: 'EffectExpression' as const,
        target,
        operator,
        equation,
      }
    }
    function BinaryExpression(operator, left, right) {
      return {
        type: 'BinaryExpression' as const,
        operator,
        left,
        right,
      }
    }
    function operatorReducer(result, element) {
      const left = result
      const right = element[3]
      const op = element[1]
      return BinaryExpression(op, left, right)
    }
    function FunctionExpression(id, parameters) {
      return {
        type: 'FunctionExpression' as const,
        name: id,
        parameters,
      }
    }
    function MemberExpression(object, property, computed) {
      return {
        type: 'MemberExpression' as const,
        object,
        property,
        computed,
      }
    }
    function propertyReducer(result, element) {
      const computed = element[1] === '.'
      const property = element[3]
      return MemberExpression(result, property, computed)
    }
    function Identifier(value) {
      return {
        type: 'Identifier' as const,
        value,
      }
    }
    function NumericLiteral(value) {
      return {
        type: 'NumericLiteral' as const,
        value: Number(value),
      }
    }
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child
      }
      C.prototype = parent.prototype
      child.prototype = new C()
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message)
      // istanbul ignore next Check is a necessary evil to support older environments
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype)
      }
      self.expected = expected
      self.found = found
      self.location = location
      self.name = 'SyntaxError'
      return self
    }
    peg$subclass(peg$SyntaxError, Error)
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || ' '
      if (str.length > targetLength) {
        return str
      }
      targetLength -= str.length
      padString += padString.repeat(targetLength)
      return str + padString.slice(0, targetLength)
    }
    peg$SyntaxError.prototype.format = function (sources) {
      var str = 'Error: ' + this.message
      if (this.location) {
        var src = null
        var k
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g)
            break
          }
        }
        var s = this.location.start
        var offset_s =
          this.location.source &&
            typeof this.location.source.offset === 'function'
            ? // @ts-ignore
            this.location.source.offset(s)
            : // @ts-ignore
            s
        var loc =
          this.location.source + ':' + offset_s.line + ':' + offset_s.column
        if (src) {
          var e = this.location.end
          var filler = peg$padEnd('', offset_s.line.toString().length, ' ')
          var line = src[s.line - 1]
          var last = s.line === e.line ? e.column : line.length + 1
          var hatLen = last - s.column || 1
          str +=
            '\n --> ' +
            loc +
            '\n' +
            filler +
            ' |\n' +
            offset_s.line +
            ' | ' +
            line +
            '\n' +
            filler +
            ' | ' +
            peg$padEnd('', s.column - 1, ' ') +
            peg$padEnd('', hatLen, '^')
        } else {
          str += '\n at ' + loc
        }
      }
      return str
    }
    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return '"' + literalEscape(expectation.text) + '"'
        },
        class: function (expectation) {
          var escapedParts = expectation.parts.map(function (part) {
            return Array.isArray(part)
              ? // @ts-ignore
              classEscape(part[0]) + '-' + classEscape(part[1])
              : // @ts-ignore
              classEscape(part)
          })
          return (
            '[' +
            (expectation.inverted ? '^' : '') +
            escapedParts.join('') +
            ']'
          )
        },
        any: function () {
          return 'any character'
        },
        end: function () {
          return 'end of input'
        },
        other: function (expectation) {
          return expectation.description
        },
      }
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase()
      }
      function literalEscape(s) {
        return (
          s
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\0/g, '\\0')
            .replace(/\t/g, '\\t')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/[\x00-\x0F]/g, function (ch) {
              return '\\x0' + hex(ch)
            })
            .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
              return '\\x' + hex(ch)
            })
        )
      }
      function classEscape(s) {
        return (
          s
            .replace(/\\/g, '\\\\')
            .replace(/\]/g, '\\]')
            .replace(/\^/g, '\\^')
            .replace(/-/g, '\\-')
            .replace(/\0/g, '\\0')
            .replace(/\t/g, '\\t')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/[\x00-\x0F]/g, function (ch) {
              return '\\x0' + hex(ch)
            })
            .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
              return '\\x' + hex(ch)
            })
        )
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation)
      }
      function describeExpected(expected) {
        var descriptions = expected.map(describeExpectation)
        var i, j
        descriptions.sort()
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i]
              j++
            }
          }
          descriptions.length = j
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0]
          case 2:
            return descriptions[0] + ' or ' + descriptions[1]
          default:
            return (
              descriptions.slice(0, -1).join(', ') +
              ', or ' +
              descriptions[descriptions.length - 1]
            )
        }
      }
      function describeFound(found) {
        return found ? '"' + literalEscape(found) + '"' : 'end of input'
      }
      return (
        'Expected ' +
        describeExpected(expected) +
        ' but ' +
        describeFound(found) +
        ' found.'
      )
    }
    function peg$parse(input, options) {
      options = options !== undefined ? options : {}
      var peg$FAILED = {}
      var peg$source = options.grammarSource
      var peg$startRuleFunctions = { Effects: peg$parseEffects }
      var peg$startRuleFunction = peg$parseEffects
      var peg$c0 = '\n'
      var peg$c1 = '+'
      var peg$c2 = '-'
      var peg$c3 = '*'
      var peg$c4 = '/'
      var peg$c5 = '^'
      var peg$c6 = '('
      var peg$c7 = ')'
      var peg$c8 = ','
      var peg$c9 = '['
      var peg$c10 = ']'
      var peg$c11 = '.'
      var peg$c12 = ':='
      var peg$c13 = '+='
      var peg$c14 = '*='
      var peg$c15 = '>='
      var peg$c16 = '<='

      var peg$r0 = /^[a-zA-Z_]/
      var peg$r1 = /^[0-9]/
      var peg$r2 = /^[ \t]/

      var peg$e0 = peg$literalExpectation('\n', false)
      var peg$e1 = peg$literalExpectation('+', false)
      var peg$e2 = peg$literalExpectation('-', false)
      var peg$e3 = peg$literalExpectation('*', false)
      var peg$e4 = peg$literalExpectation('/', false)
      var peg$e5 = peg$literalExpectation('^', false)
      var peg$e6 = peg$literalExpectation('(', false)
      var peg$e7 = peg$literalExpectation(')', false)
      var peg$e8 = peg$literalExpectation(',', false)
      var peg$e9 = peg$literalExpectation('[', false)
      var peg$e10 = peg$literalExpectation(']', false)
      var peg$e11 = peg$literalExpectation('.', false)
      var peg$e12 = peg$classExpectation(
        [['a', 'z'], ['A', 'Z'], '_'],
        false,
        false
      )
      var peg$e13 = peg$classExpectation([['0', '9']], false, false)
      var peg$e14 = peg$literalExpectation(':=', false)
      var peg$e15 = peg$literalExpectation('+=', false)
      var peg$e16 = peg$literalExpectation('*=', false)
      var peg$e17 = peg$literalExpectation('>=', false)
      var peg$e18 = peg$literalExpectation('<=', false)
      var peg$e19 = peg$otherExpectation('whitespace')
      var peg$e20 = peg$classExpectation([' ', '\t'], false, false)

      var peg$f0 = function (head, tail) {
        return [head, ...tail]
      } // @ts-ignore

      var peg$f1 = function (target, operator, equation) {
        return EffectExpression(target, operator, equation)
      } // @ts-ignore

      var peg$f2 = function (head, tail) {
        return tail.reduce(operatorReducer, head)
      } // @ts-ignore

      var peg$f3 = function (head, tail) {
        return tail.reduce(operatorReducer, head)
      } // @ts-ignore

      var peg$f4 = function (head, tail) {
        return tail.reduce(operatorReducer, head)
      } // @ts-ignore

      var peg$f5 = function (id, parameters) {
        return FunctionExpression(id, parameters)
      } // @ts-ignore

      var peg$f6 = function (head, tail) {
        return [head, ...tail]
      } // @ts-ignore

      var peg$f7 = function (head, tail) {
        return tail.reduce(propertyReducer, head)
      } // @ts-ignore

      var peg$f8 = function () {
        return Identifier(text())
      } // @ts-ignore

      var peg$f9 = function () {
        return NumericLiteral(text())
      }
      var peg$currPos = 0
      var peg$savedPos = 0
      var peg$posDetailsCache = [{ line: 1, column: 1 }]
      var peg$maxFailPos = 0
      var peg$maxFailExpected = []
      var peg$silentFails = 0
      var peg$result
      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".'
          )
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule]
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos)
      }
      function offset() {
        return peg$savedPos
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos,
        }
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos)
      }
      function expected(description, location) {
        location =
          location !== undefined
            ? // @ts-ignore
            location
            : // @ts-ignore
            peg$computeLocation(peg$savedPos, peg$currPos)
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location
        )
      }
      function error(message, location) {
        location =
          location !== undefined
            ? // @ts-ignore
            location
            : // @ts-ignore
            peg$computeLocation(peg$savedPos, peg$currPos)
        throw peg$buildSimpleError(message, location)
      }
      function peg$literalExpectation(text, ignoreCase) {
        return { type: 'literal', text: text, ignoreCase: ignoreCase }
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: 'class',
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase,
        }
      }
      function peg$anyExpectation() {
        return { type: 'any' }
      }
      function peg$endExpectation() {
        return { type: 'end' }
      }
      function peg$otherExpectation(description) {
        return { type: 'other', description: description }
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos]
        var p
        if (details) {
          return details
        } else {
          p = pos - 1
          while (!peg$posDetailsCache[p]) {
            p--
          }
          details = peg$posDetailsCache[p]
          details = {
            line: details.line,
            column: details.column,
          }
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++
              details.column = 1
            } else {
              details.column++
            }
            p++
          }
          peg$posDetailsCache[pos] = details
          return details
        }
      }
      function peg$computeLocation(startPos, endPos, offset) {
        var startPosDetails = peg$computePosDetails(startPos)
        var endPosDetails = peg$computePosDetails(endPos)
        var res = {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column,
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column,
          },
        }
        if (offset && peg$source && typeof peg$source.offset === 'function') {
          res.start = peg$source.offset(res.start)
          res.end = peg$source.offset(res.end)
        }
        return res
      }
      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos
          peg$maxFailExpected = []
        }
        peg$maxFailExpected.push(expected)
      }
      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location)
      }
      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected, found),
          expected,
          found,
          location
        )
      }
      function // @ts-ignore
        peg$parseEffects() {
        var s0, s1, s2, s3, s4, s5, s6, s7
        s0 = peg$currPos
        s1 = peg$parseEffectExpression()
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          s3 = []
          s4 = peg$currPos
          if (input.charCodeAt(peg$currPos) === 10) {
            s5 = peg$c0
            peg$currPos++
          } else {
            s5 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e0)
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseEffectExpression()
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_()
              s4 = s6
            } else {
              peg$currPos = s4
              s4 = peg$FAILED
            }
          } else {
            peg$currPos = s4
            s4 = peg$FAILED
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4)
            s4 = peg$currPos
            if (input.charCodeAt(peg$currPos) === 10) {
              s5 = peg$c0
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e0)
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseEffectExpression()
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_()
                s4 = s6
              } else {
                peg$currPos = s4
                s4 = peg$FAILED
              }
            } else {
              peg$currPos = s4
              s4 = peg$FAILED
            }
          }
          peg$savedPos = s0
          s0 = peg$f0(s1, s3)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseEffectExpression() {
        var s0, s1, s2, s3, s4, s5
        s0 = peg$currPos
        s1 = peg$parseMemberExpression()
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          s3 = peg$parseAssignmentOperator()
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_()
            s5 = peg$parseExpression()
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0
              s0 = peg$f1(s1, s3, s5)
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseExpression() {
        var s0, s1, s2, s3, s4, s5, s6, s7
        s0 = peg$currPos
        s1 = peg$parseTerm()
        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$currPos
          s4 = peg$parse_()
          if (input.charCodeAt(peg$currPos) === 43) {
            s5 = peg$c1
            peg$currPos++
          } else {
            s5 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e1)
            }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s5 = peg$c2
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e2)
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_()
            s7 = peg$parseTerm()
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7]
              s3 = s4
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$currPos
            s4 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 43) {
              s5 = peg$c1
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e1)
              }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s5 = peg$c2
                peg$currPos++
              } else {
                s5 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2)
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_()
              s7 = peg$parseTerm()
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7]
                s3 = s4
              } else {
                peg$currPos = s3
                s3 = peg$FAILED
              }
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          }
          peg$savedPos = s0
          s0 = peg$f2(s1, s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseTerm() {
        var s0, s1, s2, s3, s4, s5, s6, s7
        s0 = peg$currPos
        s1 = peg$parseFactor()
        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$currPos
          s4 = peg$parse_()
          if (input.charCodeAt(peg$currPos) === 42) {
            s5 = peg$c3
            peg$currPos++
          } else {
            s5 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e3)
            }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s5 = peg$c4
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e4)
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_()
            s7 = peg$parseFactor()
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7]
              s3 = s4
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$currPos
            s4 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 42) {
              s5 = peg$c3
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e3)
              }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s5 = peg$c4
                peg$currPos++
              } else {
                s5 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4)
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_()
              s7 = peg$parseFactor()
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7]
                s3 = s4
              } else {
                peg$currPos = s3
                s3 = peg$FAILED
              }
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          }
          peg$savedPos = s0
          s0 = peg$f3(s1, s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseFactor() {
        var s0, s1, s2, s3, s4, s5, s6, s7
        s0 = peg$currPos
        s1 = peg$parseGroup()
        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$currPos
          s4 = peg$parse_()
          if (input.charCodeAt(peg$currPos) === 94) {
            s5 = peg$c5
            peg$currPos++
          } else {
            s5 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e5)
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_()
            s7 = peg$parseFactor()
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7]
              s3 = s4
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$currPos
            s4 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 94) {
              s5 = peg$c5
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e5)
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_()
              s7 = peg$parseFactor()
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7]
                s3 = s4
              } else {
                peg$currPos = s3
                s3 = peg$FAILED
              }
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          }
          peg$savedPos = s0
          s0 = peg$f4(s1, s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseGroup() {
        var s0, s1, s2, s3
        s0 = peg$currPos
        s1 = peg$parse_()
        s2 = peg$parsePrimary()
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_()
          s0 = s2
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parsePrimary() {
        var s0
        s0 = peg$parseParenthesizedExpression()
        if (s0 === peg$FAILED) {
          s0 = peg$parseFunctionExpression()
          if (s0 === peg$FAILED) {
            s0 = peg$parseMemberExpression()
            if (s0 === peg$FAILED) {
              s0 = peg$parseNumericLiteral()
            }
          }
        }
        return s0
      }
      function // @ts-ignore
        peg$parseParenthesizedExpression() {
        var s0, s1, s2, s3, s4, s5
        s0 = peg$currPos
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c6
          peg$currPos++
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e6)
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          s3 = peg$parseExpression()
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c7
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e7)
              }
            }
            if (s5 !== peg$FAILED) {
              s0 = s3
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseFunctionExpression() {
        var s0, s1, s2, s3
        s0 = peg$currPos
        s1 = peg$parseMemberExpression()
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          s3 = peg$parseCallExpression()
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0
            s0 = peg$f5(s1, s3)
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseCallExpression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9
        s0 = peg$currPos
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c6
          peg$currPos++
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e6)
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          s3 = peg$currPos
          s4 = peg$parseExpression()
          if (s4 !== peg$FAILED) {
            s3 = s4
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
          if (s3 !== peg$FAILED) {
            s4 = []
            s5 = peg$currPos
            s6 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 44) {
              s7 = peg$c8
              peg$currPos++
            } else {
              s7 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e8)
              }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_()
              s9 = peg$parseExpression()
              if (s9 !== peg$FAILED) {
                s5 = s9
              } else {
                peg$currPos = s5
                s5 = peg$FAILED
              }
            } else {
              peg$currPos = s5
              s5 = peg$FAILED
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5)
              s5 = peg$currPos
              s6 = peg$parse_()
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c8
                peg$currPos++
              } else {
                s7 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e8)
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_()
                s9 = peg$parseExpression()
                if (s9 !== peg$FAILED) {
                  s5 = s9
                } else {
                  peg$currPos = s5
                  s5 = peg$FAILED
                }
              } else {
                peg$currPos = s5
                s5 = peg$FAILED
              }
            }
            s5 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 41) {
              s6 = peg$c7
              peg$currPos++
            } else {
              s6 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e7)
              }
            }
            if (s6 !== peg$FAILED) {
              peg$savedPos = s0
              s0 = peg$f6(s3, s4)
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseMemberExpression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9
        s0 = peg$currPos
        s1 = peg$parseIdentifier()
        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$currPos
          s4 = peg$parse_()
          if (input.charCodeAt(peg$currPos) === 91) {
            s5 = peg$c9
            peg$currPos++
          } else {
            s5 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e9)
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_()
            s7 = peg$parseExpression()
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_()
              if (input.charCodeAt(peg$currPos) === 93) {
                s9 = peg$c10
                peg$currPos++
              } else {
                s9 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10)
                }
              }
              if (s9 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7, s8, s9]
                s3 = s4
              } else {
                peg$currPos = s3
                s3 = peg$FAILED
              }
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos
            s4 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 46) {
              s5 = peg$c11
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e11)
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_()
              s7 = peg$parseIdentifier()
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7]
                s3 = s4
              } else {
                peg$currPos = s3
                s3 = peg$FAILED
              }
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$currPos
            s4 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 91) {
              s5 = peg$c9
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e9)
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_()
              s7 = peg$parseExpression()
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_()
                if (input.charCodeAt(peg$currPos) === 93) {
                  s9 = peg$c10
                  peg$currPos++
                } else {
                  s9 = peg$FAILED
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e10)
                  }
                }
                if (s9 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7, s8, s9]
                  s3 = s4
                } else {
                  peg$currPos = s3
                  s3 = peg$FAILED
                }
              } else {
                peg$currPos = s3
                s3 = peg$FAILED
              }
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos
              s4 = peg$parse_()
              if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c11
                peg$currPos++
              } else {
                s5 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11)
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_()
                s7 = peg$parseIdentifier()
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7]
                  s3 = s4
                } else {
                  peg$currPos = s3
                  s3 = peg$FAILED
                }
              } else {
                peg$currPos = s3
                s3 = peg$FAILED
              }
            }
          }
          peg$savedPos = s0
          s0 = peg$f7(s1, s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        return s0
      }
      function // @ts-ignore
        peg$parseIdentifier() {
        var s0, s1, s2
        s0 = peg$currPos
        s1 = []
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s2 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e12)
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2)
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos)
              peg$currPos++
            } else {
              s2 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e12)
              }
            }
          }
        } else {
          s1 = peg$FAILED
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0
          s1 = peg$f8()
        }
        s0 = s1
        return s0
      }
      function // @ts-ignore
        peg$parseNumericLiteral() {
        var s0, s1, s2, s3, s4, s5, s6
        s0 = peg$currPos
        s1 = peg$parse_()
        s2 = []
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s3 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e13)
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3)
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos)
            peg$currPos++
          } else {
            s3 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e13)
            }
          }
        }
        s3 = peg$currPos
        if (input.charCodeAt(peg$currPos) === 46) {
          s4 = peg$c11
          peg$currPos++
        } else {
          s4 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e11)
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = []
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos)
            peg$currPos++
          } else {
            s6 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e13)
            }
          }
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6)
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos)
                peg$currPos++
              } else {
                s6 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e13)
                }
              }
            }
          } else {
            s5 = peg$FAILED
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5]
            s3 = s4
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
        } else {
          peg$currPos = s3
          s3 = peg$FAILED
        }
        if (s3 === peg$FAILED) {
          s3 = null
        }
        s4 = peg$parse_()
        peg$savedPos = s0
        s0 = peg$f9()
        return s0
      }
      function // @ts-ignore
        peg$parseAssignmentOperator() {
        var s0
        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12
          peg$currPos += 2
        } else {
          s0 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e14)
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c13) {
            s0 = peg$c13
            peg$currPos += 2
          } else {
            s0 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e15)
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c14) {
              s0 = peg$c14
              peg$currPos += 2
            } else {
              s0 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e16)
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c15) {
                s0 = peg$c15
                peg$currPos += 2
              } else {
                s0 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e17)
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c16) {
                  s0 = peg$c16
                  peg$currPos += 2
                } else {
                  s0 = peg$FAILED
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e18)
                  }
                }
              }
            }
          }
        }
        return s0
      }
      function // @ts-ignore
        peg$parse_() {
        var s0, s1
        peg$silentFails++
        s0 = []
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e20)
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1)
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos)
            peg$currPos++
          } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e20)
            }
          }
        }
        peg$silentFails--
        s1 = peg$FAILED
        if (peg$silentFails === 0) {
          peg$fail(peg$e19)
        }
        return s0
      }
      peg$result = peg$startRuleFunction()
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation())
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length
            ? // @ts-ignore
            peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : // @ts-ignore
            peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        )
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse,
    }
  })()

export interface FilePosition {
  offset: number
  line: number
  column: number
}

export interface FileRange {
  start: FilePosition
  end: FilePosition
  source: string
}

export interface LiteralExpectation {
  type: 'literal'
  text: string
  ignoreCase: boolean
}

export interface ClassParts extends Array<string | ClassParts> {}

export interface ClassExpectation {
  type: 'class'
  parts: ClassParts
  inverted: boolean
  ignoreCase: boolean
}

export interface AnyExpectation {
  type: 'any'
}

export interface EndExpectation {
  type: 'end'
}

export interface OtherExpectation {
  type: 'other'
  description: string
}

export type Expectation =
  | LiteralExpectation
  | ClassExpectation
  | AnyExpectation
  | EndExpectation
  | OtherExpectation

declare class _PeggySyntaxError extends Error {
  public static buildMessage(
    expected: Expectation[],
    found: string | null
  ): string
  public message: string
  public expected: Expectation[]
  public found: string | null
  public location: FileRange
  public name: string
  constructor(
    message: string,
    expected: Expectation[],
    found: string | null,
    location: FileRange
  )
  format(
    sources: {
      source?: any
      text: string
    }[]
  ): string
}

export interface TraceEvent {
  type: string
  rule: string
  result?: any
  location: FileRange
}

declare class _DefaultTracer {
  private indentLevel: number
  public trace(event: TraceEvent): void
}

peggyParser.SyntaxError.prototype.name = 'PeggySyntaxError'

export interface ParseOptions {
  filename?: string
  startRule?: 'Effects'
  tracer?: any
  [key: string]: any
}
export type ParseFunction = <Options extends ParseOptions>(
  input: string,
  options?: Options
) => Options extends { startRule: infer StartRule }
  ? StartRule extends 'Effects'
    ? Effects
    : Effects
  : Effects
export const parse: ParseFunction = peggyParser.parse

export const PeggySyntaxError =
  peggyParser.SyntaxError as typeof _PeggySyntaxError

export type PeggySyntaxError = _PeggySyntaxError

// These types were autogenerated by ts-pegjs
export type Effects = [EffectExpression, ...EffectExpression[]]
export type EffectExpression = {
  type: 'EffectExpression'
  target: any
  operator: any
  equation: any
}
export type Expression = any
export type Term = any
export type Factor = any
export type Group = Primary
export type Primary =
  | ParenthesizedExpression
  | FunctionExpression
  | MemberExpression
  | NumericLiteral
export type ParenthesizedExpression = Expression
export type FunctionExpression = {
  type: 'FunctionExpression'
  name: any
  parameters: any
}
export type CallExpression = [Expression, ...Expression[]]
export type MemberExpression = any
export type Identifier = { type: 'Identifier'; value: any }
export type NumericLiteral = { type: 'NumericLiteral'; value: number }
export type AssignmentOperator = ':=' | '+=' | '*=' | '>=' | '<='
export type _ = string[]
