{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>5esheets is a work in progress D&amp;D 5e character sheet web-application that you can run yourself without any external system dependency (database, search engine, etc).</p>"},{"location":"#what-5esheets-is","title":"What 5esheets is","text":"<p>5esheets is a character sheet manager. It allows players to keep track of their players, and dungeons masters to keep track of their players' character. It is aimed at providing a clearer layout than the official character sheet, while giving players some flexibility in how their sheet is organized.</p> <p>It is intended to be self-hostable, easy to back-up and manage.</p>"},{"location":"#what-5esheets-isnt","title":"What 5esheets isn't","text":"<p>5esheets is not a virtual tabletop, like Foundry, Fantasy Grounds or Roll20. We have no plan to support maps, tokens, lightning effects, etc. We only want to provide a character sheet manager.</p>"},{"location":"design/","title":"Design","text":"<p>5esheets was designed with several goals in mind:</p> <ul> <li>use modern and robust backend and frontend tooling, as a playground for experimentation</li> <li>build on top of giants, to minimize boilerplate code</li> <li>be fully external-dependencies-free (database, search engine, cache, etc). Everything should leverage SQLite to make the app extremely easy to run, and the data trivial to backup.</li> <li>depart from the official 5e character sheet layout where we find it appropriate, to allow you to input as much information as you need</li> <li>link all SRD items, spells, etc to 5e.tools</li> <li>implement the character sheet as an SPA that would query a backend API, for ease of use</li> </ul>"},{"location":"design/#technical-design-choices","title":"Technical design choices","text":"<p>We have designed 5esheets by making deliberate technical choices, revolving around a mix of experimentation with modern tooling, while making the application as robust and pleasant to develop in as possible.</p>"},{"location":"design/#design-choices-for-the-backend-application","title":"Design choices for the backend application","text":""},{"location":"design/#language","title":"Language","text":"<p>We chose Python for our backend. It's a language we know really well, that is fast enough for what we have in mind, with an extremely rich set of libraries to build web applications and API with.</p>"},{"location":"design/#web-framework","title":"Web framework","text":"<p>We decided to rely on FastAPI for the backend API. It handles request routing and parsing, input/output payload schema validation and (de)serialization, and OpenAPI schema generation (amongst many other things). It is fully compatible with the <code>async/await</code> Python features, allowing us to rely on asynchonous SQL queries to minimize the server footprint (a single process/thread is required).</p>"},{"location":"design/#authentication","title":"Authentication","text":"<p>We leverage JWTs to authenticate API calls to the backend. To avoid reinventing the wheel when it comes to security, we used <code>fastapi-jwt</code> (which is more actively maintained than <code>fastapi-auth-jwt</code>) rather than implementing this layer ourselves, as suggested in the FastAPI documentation.</p>"},{"location":"design/#orm","title":"ORM","text":"<p>We rely on SQLAlchemy to execute SQL requests asynchonously. It integrates well with Pydantic (the library used by FastAPI to validate schemas), allowing us to easily define input/output schemas based on the ORM models.</p>"},{"location":"design/#admin-ui","title":"Admin UI","text":"<p>We rely on SQLAdmin to integrate with our SQLAlchemy models in order to display an admin UI for our backend data.</p>"},{"location":"design/#database","title":"Database","text":"<p>We use SQLlite to store the data, as it is a much more competent database that usually given credit for. We use it as a regular SQL database, as well as a full-text search engine for SRD resources.</p>"},{"location":"design/#design-choices-for-the-frontend-application","title":"Design choices for the frontend application","text":""},{"location":"design/#language_1","title":"Language","text":"<p>We rely on Typescript to help us write correct code, free of runtime crashes. It is a battle-tested language, widely used in production in products with, much, much more stringent reliability requirements than this one.</p>"},{"location":"design/#api-client","title":"API Client","text":"<p>We rely on <code>openapi-typescript-codegen</code> to automatically generate the API client, models and interfaces for the 5esheets API client used by our frontend, based on the OpenAPI json schema generated by FastAPI. This allows us to iterate quickly on our data model while keeping the amount of manual synchronization between our backend and frontend close to nil.</p>"},{"location":"design/#reactivity-library","title":"Reactivity library","text":"<p>Instead of going for React, we decided to experiment with SolidJS. This is where we spent our innovation token, as it took us quite a while to get accustomed to. We wanted a modern reactivity library that was as efficient as possible, with as much explicitness as possible in the definition of depencencies between components.</p>"},{"location":"local-development/","title":"Local development","text":"<p>This project is intended to be run on Linux or macOS, and requires <code>poetry</code> and <code>npm</code> to be installed to install python and javascript dependencies.</p> <p>We however provide a docker image to run the application if somehow installing these tools prove troublesome.</p>"},{"location":"local-development/#running-the-project-in-docker","title":"Running the project in docker","text":"<p>To run both the backend API and the frontend app in docker, you simply have to run</p> <pre><code>make dev\n</code></pre> <p>This will:</p> <ul> <li>build the docker image for the backend app, with all dependencies installed</li> <li>build the docker image for the frontend app, with all dependencies installed</li> <li>run both images via docker compose</li> <li>apply the SQL migrations</li> <li>populate the database with items, spells and development fixtures</li> </ul>"},{"location":"local-development/#running-the-project-on-your-host","title":"Running the project on your host","text":"<p>If you were confortable installing <code>poetry</code> and <code>npm</code> on your development machine, and managed to, then run</p> <pre><code>make init\n</code></pre> <p>This will:</p> <ul> <li>install all backend dependencies in a virtualenv created and managed by <code>poetry</code></li> <li>install all frontend dependencies under <code>dnd5esheets/front/node_modules</code></li> <li>apply the SQL migrations</li> <li>populate the database with items, spells and development fixtures</li> </ul> <p>At that point, open 2 terminal tabs. Run the following command in the first tab to run the backend application:</p> <pre><code>make run\n</code></pre> <p>Run this command in the second terminal tab to run the frontend application:</p> <pre><code>make run-front-dev\n</code></pre>"},{"location":"local-development/#next-steps","title":"Next steps","text":"<p>At that point, the backend API will run under <code>http://localhost:8000</code> and the frontend will run under <code>http://localhost:3000</code></p> <p>Note</p> <p>When using these <code>make</code> commands, any modification to the codebase will induce automatic reload of either the backend or frontend application.</p>"},{"location":"local-development/#development-commands","title":"Development commands","text":"<p>If you run the apps directly on your development host, you might find the following <code>make</code> commands useful:</p> <pre><code>make api-doc                    Open the 5esheets API documentation\nmake api-explorer               Open the 5esheets API explorer (with interactive requests)\nmake back-test                  Run the backend tests\nmake build                      Build the application\nmake check                      Run all checks on the codebase\nmake db-dev-fixtures            Populate the local database with development fixtures\nmake db-migrate                 Run the SQL migrations\nmake deps                       Install the development dependencies\nmake dev                        Run the dev stack in containers\nmake docker-build-front-dev     Build the dev docker image for the frontend\nmake docker-build               Build the docker image for the API\nmake docs                       Generate and serve documentation\nmake front-check                Run all frontend checks\nmake front-generate-api-client  Generate the API openapi.json file\nmake front-run-dev              Run the development frontend server\nmake front-storybook            Run the development frontend storybook server\nmake front-test                 Run the frontend unit tests\nmake help                       Display help\nmake init                       Setup the application for the first time\nmake run                        Run the app\nmake test                       Run the project tests\nmake trash-env                  Delete all js dependencies and the python virtualenv\n</code></pre>"}]}