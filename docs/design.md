5esheets was designed with several goals in mind:

- use modern and robust backend and frontend tooling, as a playground for experimentation
- build on top of giants, to minimize boilerplate code
- be fully external-dependencies-free (database, search engine, cache store, etc). Everything should leverage SQLite to make the app extremely easy to run, and the data trivial to backup.
- depart from the official [5e character sheet layout](https://media.wizards.com/2022/dnd/downloads/DnD_5E_CharacterSheet_FormFillable.pdf) where we find it appropriate, to allow you to input as much information as you need
- link all SRD items, spells, etc to [5e.tools](https://5e.tools)
- implement the character sheet as an <abbr title="Single Page App">SPA</abbr> that would query a backend API, for ease of use

## Technical design choices

We have designed 5esheets by making [deliberate technical choices](https://github.com/brouberol/5esheets/milestone/1), revolving around a mix of experimentation with modern tooling, while making the application as robust and pleasant to develop in as possible.

### Design choices for the backend application

#### Language

We chose Python for our backend. It's a language we now really well, that is fast _enough_ for what we have in mind, with an extremely rich set of libraries to build web applications and API with.

#### Web framework

We decided to rely on [FastAPI](https://fastapi.tiangolo.com/features) for the backend API. It handles request routing and parsing, input/output payload schema validation and (de)serialization, and OpenAPI schema generation (amongst many other things). It is fully compatible with the `async/await` Python features, allowing us to rely on asynchonous SQL queries to minimize the server footprint (a single process/thread is required).

#### ORM

We rely on [SQLAlchemy](https://docs.sqlalchemy.org) to execute SQL requests asynchonously. It integrates well with [Pydantic](https://docs.pydantic.dev/latest/) (the library used by FastAPI to validate schemas), allowing us to easily define input/output schemas based on the ORM models.

#### Admin UI

We rely on [SQLAdmin](https://aminalaee.dev/sqladmin/) to integrate with our SQLAlchemy models in order to display an admin UI for our backend data.

#### Database

We use [SQLlite](https://sqlite.org) to store the data, as it is a much more competent database that usually given credit for. We use it as a regular SQL database, as well as a full-text search engine for SRD resources.

### Design choices for the frontend application

#### Language

We rely on [Typescript](https://www.typescriptlang.org) to help us write correct code, without runtime crashes. It is a battle-tested language, widely used in production in products with, much, _much_ more stringent reliability requirements than this one.

#### API Client

We rely on [`openapi-typescript-codegen`](https://github.com/ferdikoomen/openapi-typescript-codegen) to automatically generate the API client, models and interfaces for the 5esheets API client used by our frontend, based on the OpenAPI json schema generated by FastAPI. This allows us to iterate quickly on our data model while keeping the amount of manual synchronization between our backend and frontend close to nil.

#### Reactivity library

Instead of going for React, we decided to experiment with [SolidJS](https://www.solidjs.com/). This is where we spent our [innovation token](https://matt-rickard.com/innovation-tokens), as it took us quite a while to get accustomed to. We wanted a modern reactivity library that was as efficient as possible, with as much explicitness as possible in the definition of depencencies between components.
